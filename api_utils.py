import json
import re
import ast
from typing import Callable
from fastapi import Request, Response
from fastapi.routing import APIRoute

def fix_json_string(raw_str: str) -> str:
    """Attempt to fix malformed JSON strings commonly generated by LLMs."""
    # 1. Try standard parse (fast path)
    try:
        json.loads(raw_str)
        return raw_str
    except json.JSONDecodeError:
        pass
    
    # 2. Fix Python booleans and unquoted single quotes
    fixed = re.sub(r'\bTrue\b', 'true', raw_str)
    fixed = re.sub(r'\bFalse\b', 'false', fixed)
    fixed = re.sub(r'\bNone\b', 'null', fixed)
    
    try:
        json.loads(fixed)
        return fixed
    except json.JSONDecodeError:
        pass
        
    # 3. Fallback to ast.literal_eval for single-quoted dicts
    try:
        parsed_dict = ast.literal_eval(fixed)
        if isinstance(parsed_dict, dict) or isinstance(parsed_dict, list):
            return json.dumps(parsed_dict)
    except Exception:
        pass
        
    # Return original if we can't fix it; FastAPI will throw 422 naturally
    return raw_str

class GracefulJSONRoute(APIRoute):
    """
    A custom FastAPI Route class that intercepts incoming JSON requests,
    attempts to fix malformed single-quoted or boolean-botched JSON strings,
    and replaces the request body before Pydantic validation kicks in.
    """
    def get_route_handler(self) -> Callable:
        original_route_handler = super().get_route_handler()
        
        async def custom_route_handler(request: Request) -> Response:
            # Only intercept JSON requests
            if "application/json" in request.headers.get("content-type", "").lower():
                try:
                    body_bytes = await request.body()
                    if body_bytes:
                        raw_str = body_bytes.decode("utf-8")
                        fixed_str = fix_json_string(raw_str)
                        
                        if fixed_str != raw_str:
                            # Replace the body in the request so downstream Pydantic sees the fixed JSOn
                            fixed_bytes = fixed_str.encode("utf-8")
                            request._body = fixed_bytes
                            async def receive():
                                return {"type": "http.request", "body": fixed_bytes}
                            request._receive = receive
                except Exception as e:
                    # If reading body fails, ignore and let standard pipeline handle it
                    pass
                    
            return await original_route_handler(request)
            
        return custom_route_handler
