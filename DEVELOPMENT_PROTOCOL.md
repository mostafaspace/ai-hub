# Antigravity Development Protocol

## üö® MANDATORY CHECKLIST üö®
**MUST BE CHECKED AND FOLLOWED FOR EVERY TASK.**

For every feature implementation, code change, or new server addition, you **MUST** perform the following actions automatically:

### 1. üìâ Resource Management (Auto-Unload)
- [ ] **Implement Auto-Unload**: Ensure models automatically unload from VRAM after a period of inactivity (default: 60-600s depending on model size).
- [ ] **Verify Unload**: Confirm verification scripts check that VRAM is released.

### 2. üìö Documentation Updates
- [ ] **Update README.md**: Add new services, features, or configuration changes to the main `README.md`.
- [ ] **Update API Docs**: Ensure `openapi.yaml` or equivalent API documentation reflects all endpoint changes.
- [ ] **Update Skills**: Update `SKILL.md` files in `openclaw_skills/` to match new agent capabilities.

### 3. ‚úÖ Verification & Testing
- [ ] **Test Everything**: Run `test_all_servers.py` to ensure no regressions.
- [ ] **Verify End-to-End**: Ensure the entire flow (request -> processing -> response -> unload) works smoothly.

### 4. üîÑ Unified Launcher Sync
- [ ] **Sync Launchers**: Always update `unified_server.py` AND `run_server.bat` together when modifying server startup logic.
- [ ] **Streamlined Updates**: Ensure changes in one are reflected in the other to maintain a consistent unified experience.
- [ ] **Integrity Check**: Verify that `run_server.bat` correctly calls `unified_server.py` with necessary arguments.

### 5. üö¶ Concurrency & Lock Management
- [ ] **PyTorch Inference Locks**: Multi-tenant/Agent setups *must* wrap heavy generation logic in a lock (`threading.Lock()` for threads, `asyncio.Lock()` for async) to prevent overlapping VRAM allocation or model offload racing (e.g., `accelerate` crashing on device mismatches).
- [ ] **Async vs Sync Context**: Do not use `threading.Lock()` blindly inside `async def` FastAPI endpoints. Use `asyncio.Lock()` to prevent the event loop from blocking completely.

### 6. üõ°Ô∏è Agent Interaction Resiliency
- [ ] **Graceful JSON Fallbacks**: When building APIs for LLMs/Agents, do not rely on standard `request.json()`. Agents often send malformed JSON (Python single-quotes instead of double, boolean `True` instead of `true`). Use multi-strategy parsing with regex fixers and `ast.literal_eval` as a fallback, returning `400 Bad Request` instead of `500 Server Error`.
- [ ] **Windows CLI Submissions**: `curl` commands generated by agents frequently truncate JSON payloads at the first space due to Windows CMD quote escaping bugs. API instructions (`SKILL.md`) **must** direct agents to write payloads to temporary `payload.json` files and use `curl -d @payload.json` instead of inline strings.

### 7. üóÑÔ∏è Caching Data Structs
- [ ] **Strict Serialization**: When using local caches (like Redis or in-memory dicts) that return JSON strings via `query_result` or HTTP responses, **always** ensure data pushed to the cache is serialized (`json.dumps()`). If Python lists/dicts are pushed raw and someone calls `json.loads(cached_data)`, the API thread will silently crash or hang agent polling loops indefinitely.
